set encoding=utf-8
set fileencoding=utf-8

set ttimeoutlen=10

set cursorline
set fillchars=vert:│,fold:-
set incsearch
set lazyredraw
set nocompatible
set noshowmode
set noswapfile
set number
set relativenumber
set scrolloff=9999
set shiftwidth=4
set showcmd
set smartindent
set tabstop=4
set wildmenu

" ignore swap warnings
set shortmess+=A

" when searching
set smartcase
set ignorecase

" allow for deleting existing file content
set backspace=indent,eol,start

" more natural splits
set splitbelow
set splitright

if &term =~ '^screen'
	set ttymouse=xterm2
endif

filetype on

au BufRead,BufNewFile *.fig setfiletype pug
au BufRead,BufNewFile *.tex setfiletype tex

set nofoldenable
set foldmethod=indent
au BufWinLeave ?* mkview 1

let g:mapleader = ","

nnoremap <silent> <c-w>\| :vsplit<cr>
nnoremap <silent> <c-w>- :split<cr>
nnoremap <silent> <c-w>_ :split<cr>
nnoremap <silent> <c-h> <c-w>h
nnoremap <silent> <c-j> <c-w>j
nnoremap <silent> <c-k> <c-w>k
nnoremap <silent> <c-l> <c-w>l

nnoremap <silent> <Leader>a :call AckSearch('')<Left><Left>
nnoremap <silent> <Leader>e :NERDTree<CR>

" fzf.vim files search
nnoremap <silent> <Leader>f :Files<CR>

nnoremap <silent> <Leader>m :set mouse=a<CR>
nnoremap <silent> <Leader>n :set mouse=<CR>
nnoremap <silent> <Leader>p :set invpaste<CR>
nnoremap <silent> <Leader>s :UltiSnipsEdit<CR>
nnoremap <silent> <Leader>q :cclose<CR>
nnoremap <silent> <Leader>v :source ~/.vim/vimrc<CR>

" fzf.vim buffer search window
nnoremap <silent> <space> :Buffers<CR>

nmap <silent> [s <Plug>(ale_previous_wrap)
nmap <silent> ]s <Plug>(ale_next_wrap)

vnoremap gs :'<,'>sort<CR>

set laststatus=2

if ! has('gui_running')
	set ttimeoutlen=10
	augroup FastEscape
		autocmd!
		au InsertEnter * set timeoutlen=0
		au InsertLeave * set timeoutlen=1000
	augroup END
endif

" ALE components copied from
" https://github.com/statico/dotfiles/blob/f6e5807b4357403e0a5b786d7220d1a7ecbe63d9/.vim/vimrc#L299

let g:lightline = {
\ 'colorscheme': 'darcula',
\ 'inactive': {
\   'left': [[], ['file', 'modified']],
\   'right': []
\ },
\ 'active': {
\   'left': [['mode', 'paste'], ['file', 'modified']],
\   'right': [['lineinfo'], ['percent'], ['readonly', 'linter_warnings', 'linter_errors', 'linter_ok']]
\ },
\ 'component': {
\   'file': '%{expand("%")}'
\ },
\ 'component_expand': {
\   'linter_warnings': 'LightlineLinterWarnings',
\   'linter_errors': 'LightlineLinterErrors',
\   'linter_ok': 'LightlineLinterOK'
\ },
\ 'component_type': {
\   'readonly': 'error',
\   'linter_warnings': 'warning',
\   'linter_errors': 'error'
\ },
\ }

function! LightlineLinterWarnings() abort
	let l:counts = ale#statusline#Count(bufnr(''))
	let l:all_errors = l:counts.error + l:counts.style_error
	let l:all_non_errors = l:counts.total - l:all_errors
	return l:counts.total == 0 ? '' : printf('%d ◆', all_non_errors)
endfunction

function! LightlineLinterErrors() abort
	let l:counts = ale#statusline#Count(bufnr(''))
	let l:all_errors = l:counts.error + l:counts.style_error
	let l:all_non_errors = l:counts.total - l:all_errors
	return l:counts.total == 0 ? '' : printf('%d ✗', all_errors)
endfunction

function! LightlineLinterOK() abort
	let l:counts = ale#statusline#Count(bufnr(''))
	let l:all_errors = l:counts.error + l:counts.style_error
	let l:all_non_errors = l:counts.total - l:all_errors
	return l:counts.total == 0 ? '✓ ' : ''
endfunction

autocmd User ALELint call s:MaybeUpdateLightline()
function! s:MaybeUpdateLightline()
	if exists('#lightline')
		call lightline#update()
	end
endfunction

let g:ale_linters = {
\	'javascript': ['xo']
\}

let g:ale_javascript_xo_options = '--extend ~/.xo.js'
let g:ale_lint_on_text_changed = 'never'
let g:ale_list_window_size = 8
let g:ale_open_list = 1
let g:ale_set_quickfix = 1
let g:ale_sign_error = '✖'
let g:ale_sign_warning = '▲'

set t_Co=256

let delimitMate_expand_cr = 1

let g:completor_refresh_always = 0

let g:UltiSnipsSnippetsDir = '~/.vim/UltiSnips'
let g:UltiSnipsEditSplit="horizontal"

let NERDTreeShowHidden=1

let g:closetag_filenames = "*.html,*.tag"

let g:gitgutter_sign_added = '∙'
let g:gitgutter_sign_modified = '∙'
let g:gitgutter_sign_modified_removed = '∙'
let g:gitgutter_sign_removed = '∙'
let g:gitgutter_sign_removed_first_line = '∙'

if executable('ag')
	let g:ackprg = 'ag --vimgrep'
endif

colorscheme dracula

function! AckSearch(string) abort
	let saved_shellpipe = &shellpipe
	let &shellpipe = '>'

	try
		execute 'Ack!' shellescape(a:string, 1)
	finally
		let &shellpipe = saved_shellpipe
	endtry

endfunction

syntax on

function! TrailingWhitespace ()
	hi clear MatchParen
	hi MatchParen cterm=bold,underline term=bold,underline

	hi ExtraWhitespace cterm=underline,bold term=bold,underline ctermfg=red
	match ExtraWhitespace /\s\+$/
endfunction

au BufWinEnter * :call TrailingWhitespace()

call TrailingWhitespace()

hi link ALEWarningSign Warn

hi Error cterm=none ctermfg=red ctermbg=none
hi Warn cterm=none ctermfg=215 ctermbg=none
hi VertSplit cterm=none ctermfg=59 ctermbg=none
hi EndOfBuffer ctermfg=59

au BufEnter * set colorcolumn=80
set colorcolumn=80
